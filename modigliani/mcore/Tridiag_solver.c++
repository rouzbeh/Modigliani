/**\file ntbp_tridiag_solver_obj.cpp - NTBP_tridiag_solver_o class implementation 
 * by Ahmed Aldo Faisal &copy; created 26.3.2001  
 */
/* NetTrader - visualisation, scientific and financial analysis and simulation system
 * Version:  0.5
 * Copyright (C) 1998,1999,2000 Ahmed Aldo Faisal    
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/* $Id: ntbp_tridiag_solver_obj.cpp,v 1.1.1.1 2004/12/16 01:38:36 face Exp $ 
 * $Log: ntbp_tridiag_solver_obj.cpp,v $
 * Revision 1.1.1.1  2004/12/16 01:38:36  face
 * Imported NetTrader 0.5 source from flyeye02.zoo.cam.ac.uk repository
 *
 * Revision 1.1  2001/10/03 14:37:52  face
 * *** empty log message ***
 *

 */
#include "Tridiag_solver.h"

/* ***      CONSTRUCTORS	***/
/** Create a NTBP_tridiag_solver_o */
NTBP_tridiag_solver_o::NTBP_tridiag_solver_o(mbase::Msize numNewCompartments) {
	M_ASSERT(numNewCompartments > 0);
	numCompartments = numNewCompartments;
	initialised = false;
	std::cerr << "OBSOLETE code called";
}

/* ***      COPY AND ASSIGNMENT	***/
NTBP_tridiag_solver_o::NTBP_tridiag_solver_o(
		const NTBP_tridiag_solver_o __attribute__((unused)) & original) :
		mbase::Obj() {
	// add assignment code here
	std::cerr << "OBSOLETE code called";
}

const NTBP_tridiag_solver_o&
NTBP_tridiag_solver_o::operator=(const NTBP_tridiag_solver_o & right) {
	if (this == &right)
		return (*this); // Gracefully handle self assignment
	// add assignment code here
	std::cerr << "OBSOLETE code called";
	return (*this);
}

/* ***      DESTRUCTOR		***/
NTBP_tridiag_solver_o::~NTBP_tridiag_solver_o() {
	std::cerr << "OBSOLETE code called";
}

/* ***  PUBLIC                                    ***   */
/*
 mbase::Mreturn
 NTBP_tridiag_solver_o::Setup(std::vector <mbase::Mreal> newLVec, std::vector <mbase::Mreal> newUVec)
 {
 std::cerr << "OBSOLETE code called";
 M_ASSERT(newLVec.size() == numCompartments);
 lOrigVec = newLVec;

 M_ASSERT(newUVec.size() == numCompartments);
 uOrigVec = newUVec;

 initialised = true;
 return (mbase::M_SUCCESS);
 }
 */

/** @short       
 @param      none
 @return     none
 \warning    unknown
 \bug        unknown
 */
std::vector<mbase::Mreal> NTBP_tridiag_solver_o::Solve(std::vector<mbase::Mreal> dVec,
		std::vector<mbase::Mreal> vVec, std::vector<mbase::Mreal> rVec) {
	std::cerr << "OBSOLETE code called";
	std::vector<mbase::Mreal> lVec;
	std::vector<mbase::Mreal> uVec;
	M_ASSERT( true == initialised);
	M_ASSERT(lVec.size() == numCompartments);
	M_ASSERT(dVec.size() == numCompartments);
	M_ASSERT(uVec.size() == numCompartments);
	M_ASSERT(vVec.size() == numCompartments);
	M_ASSERT(rVec.size() == numCompartments);
	mbase::Msize m = numCompartments;
	/* forward elimination */
	//dVec[0] = dVec[0];
	uVec[0] = uVec[0] / dVec[0];
	rVec[0] = rVec[0] / dVec[0];
	mbase::Msize i = 1;
	for (i = 1; i < m; i++) {
		dVec[i] = dVec[i] - lVec[i] * vVec[i - 1];
		rVec[i] = (rVec[i] - lVec[i] * vVec[i - 1]) / dVec[i];
		uVec[i] = uVec[i] / dVec[i];
	}

	//	dVec[m-1] -= lVec[m-1] * vVec[m-2];
	//rVec[m-1] = (rVec[m-1] - lVec[m-1] * vVec[m-2])/dVec[m-1];

	/* backward substitution */
	vVec[m - 1] = rVec[m - 1];
	for (i = m - 2; (i < m - 1); i--) {
		vVec[i] = rVec[i] - uVec[i] * vVec[i + 1];
	}

	return (vVec);
}

/* ***  PROTECTED                         ***   */
/* ***  PRIVATE                           ***   */

/* File skeleton generated by GenNTObj version 0.7. */
/**  */
mbase::Mreturn NTBP_tridiag_solver_o::Resize(mbase::Msize numNewCompartments) {
	M_ASSERT(numNewCompartments > 0);
	numCompartments = numNewCompartments;
	return (mbase::M_SUCCESS);
}
