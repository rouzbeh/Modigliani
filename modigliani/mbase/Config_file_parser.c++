/**
 * @file Config_file_parser.c++ - Config_file_parser class implementation
 * @author Ahmed Aldo Faisal &copy; created 3.7.1999
 *
 * @version:  0.0
 * Copyright (C) 1998,1999,2000 Ahmed Aldo Faisal    
 * @section LICENSE
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRAMY; without even the implied warranty of
 * MERCHAMABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include "Config_file_parser.h"

using namespace mbase;

std::string M_trimstr(std::string const& source,
		char const* delims = " \t\r\n") {
	std::string result(source);
	std::string::size_type index = result.find_last_not_of(delims);
	if (index != std::string::npos)
		result.erase(++index);

	index = result.find_first_not_of(delims);
	if (index != std::string::npos)
		result.erase(0, index);
	else
		result.erase();
	return (result);
}

/* ***      CONSTRUCTORS	***/
/** Create a Config_file_parser */
/* ***      COPY AND ASSIGNMEM	***/
Config_file_parser::Config_file_parser(std::string const& configFile) {
	std::ifstream file(configFile.c_str());

	std::string line;
	std::string name;
	std::string value;
	std::string inSection;
	int posEqual;
	while (std::getline(file, line)) {

		if (!line.length())
			continue;

		if (line[0] == '#')
			continue;
		if (line[0] == ';')
			continue;

		if (line[0] == '[') {
			inSection = M_trimstr(line.substr(1, line.find(']') - 1));
			continue;
		}

		posEqual = line.find('=');
		name = M_trimstr(line.substr(0, posEqual));
		value = M_trimstr(line.substr(posEqual + 1));

		content_[inSection + '/' + name] = Str2real(value);
	}
}

/* ***      DESTRUCTOR		***/
Config_file_parser::~Config_file_parser() {
}

/* ***  PUBLIC                                    ***   */
/** @short      Value
 @param      none
 @return     none
 \warning    unknown
 \bug        unknown
 */
Str2real const& Config_file_parser::Value(std::string const& section,
		std::string const& entry) const {

	std::map<std::string, Str2real>::const_iterator ci = content_.find(
			section + '/' + entry);

	if (ci == content_.end())
		throw "does not exist";

	return (ci->second);
}

Str2real const& Config_file_parser::Value(std::string const& section,
		std::string const& entry, double value) {
	try {
		return (Value(section, entry));
	} catch (const char *) {
		return (content_.insert(
				std::make_pair(section + '/' + entry, Str2real(value))).first->second);
	}
	return (content_.insert(
			std::make_pair(section + '/' + entry, Str2real(value))).first->second);
}

Str2real const& Config_file_parser::Value(std::string const& section,
		std::string const& entry, std::string const& value) {
	try {
		return (Value(section, entry));
	} catch (const char *) {
		return (content_.insert(
				std::make_pair(section + '/' + entry, Str2real(value))).first->second);
	}
	return (content_.insert(
			std::make_pair(section + '/' + entry, Str2real(value))).first->second);
}

/* File skeleton generated by GenMObj version 0.7. */
