/**\file ntg_neighbour_ring_graph_obj.cpp - NTG_neighbour_ring_graph_o class implementation
 * by Ahmed Aldo Faisal &copy; created 13.10.2000
 */
/* NetTrader - visualisation, scientific and financial analysis and simulation system
 * Version:  0.5
 * Copyright (C) 1998,1999,2000 Ahmed Aldo Faisal
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include "ntg_neighbour_ring_graph_obj.h"

/* ***      CONSTRUCTORS	***/
/** Create a NTG_neighbour_ring_graph_o */
NTG_neighbour_ring_graph_o::NTG_neighbour_ring_graph_o(mbase::Size_t nodes,
		mbase::Size_t neighbourhoodRange, const NTG_node_o & nodeProto,
		const NTG_edge_o __attribute__((unused)) & edgeProto) :
		NTG_undirected_graph_o() {
	M_ASSERT(neighbourhoodRange > 0);
	radius = neighbourhoodRange;
	if (radius * 2 > nodes)
		std::cerr
				<< "NTG_neighbour_ring_graph_o::NTG_neighbour_ring_graph_o - Error : not enough nodes to allow that radius length."
				<< std::endl;

	M_ASSERT(nodes > 0);
	for (mbase::Size_t ll = 0; ll < nodes; ll++) {
		if (0 == AddNode(nodeProto))
			std::cerr
					<< "NTG_neighbour_ring_graph_o::NTG_neighbour_ring_graph_o - Error : Node adding generated an error."
					<< std::endl;
	}

	NTG_NodeIdList nodeList = NodeIdList();
	NTG_NodeIdList::iterator nodeIter;

	std::vector<NTG_NodeIdList::iterator> iterVec(radius);

	for (nodeIter = nodeList.begin(); nodeIter != nodeList.end(); nodeIter++) {

		for (mbase::Size_t lli = 1; lli <= radius; lli++) {
			iterVec[lli - 1] = nodeIter;

			/* "modulo" operation on a node list */
			for (mbase::Size_t llr = 1; llr <= lli; llr++) {
				(iterVec[lli - 1])++;
				if (nodeList.end() == iterVec[lli - 1])
					iterVec[lli - 1] = nodeList.begin();
			}
			if (mbase::M_SUCCESS != SymmetricConnect(*nodeIter, *(iterVec[lli - 1])))
				std::cerr
						<< "NTG_neighbour_ring_graph_o::NTG_neighbour_ring_graph_o(mbase::Size_t nodes, mbase::Size_t neighbourhoodRange,NTG_node_o & nodeProto, NTG_edge_o & edgeProto ) : NTG_graph_o() - Error : Error creating symmetric  neighbour ring connection at radius="
						<< lli << "." << std::endl;
			// cerr <<"NTG_neighbour_ring_graph_o::NTG_neighbour_ring_graph_o - Talk : Connected ("<<*nodeIter<<","<<*(iterVec[lli-1])<<")." << std::endl;
		}

	}

}

/* ***      COPY AND ASSIGNMENT	***/
NTG_neighbour_ring_graph_o::NTG_neighbour_ring_graph_o(
		const NTG_neighbour_ring_graph_o __attribute__((unused)) & original) :
		NTG_undirected_graph_o() {
// add assignment code here
}

const NTG_neighbour_ring_graph_o&
NTG_neighbour_ring_graph_o::operator=(
		const NTG_neighbour_ring_graph_o & right) {
	if (this == &right)
		return (*this); // Gracefully handle self assignment
// add assignment code here
	return (*this);
}

/* ***      DESTRUCTOR		***/
NTG_neighbour_ring_graph_o::~NTG_neighbour_ring_graph_o() {
}

/* ***  PUBLIC                                    ***   */
/** @short
 @param      none
 @return     none
 \warning    unknown
 \bug        unknown

 void
 NTG_neighbour_ring_graph_o::() const
 {
 }
 */
/* ***  PROTECTED                         ***   */
/* ***  PRIVATE                           ***   */

/* File skeleton generated by GenNTObj version 0.7. */
