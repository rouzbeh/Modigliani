.TH "DMatrix" 3 "Wed Nov 17 2010" "Version 0.5" "NetTrader" \" -*- nroff -*-
.ad l
.nh
.SH NAME
DMatrix \- 
.PP
\fBdmatrix.h\fP Header-File for a Double-Matrix-Class Released 14.7.1997 , afaisal@techfak.uni-bielefeld.de  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <dmatrix.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBDMatrix\fP (int, int)"
.br
.ti -1c
.RI "\fBDMatrix\fP (int)"
.br
.RI "\fIinit Matrix \fP"
.ti -1c
.RI "\fBDMatrix\fP (\fBDMatrix\fP &)"
.br
.RI "\fIinit Vector \fP"
.ti -1c
.RI "\fB~DMatrix\fP ()"
.br
.RI "\fIduplicate from existent \fBDMatrix\fP object \fP"
.ti -1c
.RI "\fBDMatrix\fP \fBoperator+\fP (\fBDMatrix\fP &)"
.br
.RI "\fIaddition C = A+B \fP"
.ti -1c
.RI "\fBDMatrix\fP \fBoperator-\fP (\fBDMatrix\fP &)"
.br
.RI "\fIsubtraction C = A-B \fP"
.ti -1c
.RI "\fBDMatrix\fP \fBoperator*\fP (\fBDMatrix\fP &)"
.br
.RI "\fImultiplication A = A*B \fP"
.ti -1c
.RI "\fBDMatrix\fP \fBoperator*\fP (double)"
.br
.RI "\fIScaling, factor multiplication (from the RIGHT). \fP"
.ti -1c
.RI "\fBDMatrix\fP & \fBoperator=\fP (\fBDMatrix\fP &)"
.br
.RI "\fIequalizing :) A=B \fP"
.ti -1c
.RI "double & \fBoperator()\fP (int, int)"
.br
.RI "\fIAccess matrix components. \fP"
.ti -1c
.RI "double & \fBoperator()\fP (int)"
.br
.RI "\fIAccess vector components. \fP"
.ti -1c
.RI "void \fBPrint\fP ()"
.br
.ti -1c
.RI "double \fBSum\fP ()"
.br
.ti -1c
.RI "double \fBQuadSum\fP ()"
.br
.ti -1c
.RI "\fBDMatrix\fP \fBoperator~\fP ()"
.br
.RI "\fIcompute inverse with Gauss-elimination including Pivotizing \fP"
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "istream & \fBoperator>>\fP (istream &, \fBDMatrix\fP &)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Genuine double matrix class IMPORTANT : INDICES in Matrix START with (1,1) and end with (row,col) ! NOTE : DESTRUCTIVE methods used! Be carefull because currently methods and operators might modify the (*this) object and some generate a new one 
.PP
Definition at line 101 of file dmatrix.h.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "DMatrix::DMatrix (int r, int c)"
.PP
Definition at line 131 of file dmatrix.h.
.PP
.nf
{
elements = new double[r*c+1];
memset(elements,' ',(r*c+1)*sizeof(double));
row = r; col = c;
}
.fi
.SS "DMatrix::DMatrix (int r)"
.PP
Definition at line 138 of file dmatrix.h.
.PP
.nf
{
  elements = new double[r+1];
  memset(elements,' ',(r+1)*sizeof(double));
  row = r;col = 1;
}
.fi
.SS "DMatrix::DMatrix (\fBDMatrix\fP & copy)"
.PP
Definition at line 145 of file dmatrix.h.
.PP
.nf
{
  row = copy.row;
  col = copy.col;
  elements = new double[row*col+1];
  memcpy(elements,copy.elements,(row*col+1)*sizeof(double));
}
.fi
.SS "DMatrix::~DMatrix ()\fC [inline]\fP"
.PP
Definition at line 112 of file dmatrix.h.
.PP
.nf
{ delete elements;}
.fi
.SH "Member Function Documentation"
.PP 
.SS "double & DMatrix::operator() (int r, int c)"
.PP
Definition at line 214 of file dmatrix.h.
.PP
.nf
{
return elements[(r-1)*col+c];
}
.fi
.SS "double & DMatrix::operator() (int r)"
.PP
Definition at line 221 of file dmatrix.h.
.PP
.nf
{
return elements[r];
}
.fi
.SS "\fBDMatrix\fP DMatrix::operator* (double factor)"
.PP
Definition at line 187 of file dmatrix.h.
.PP
.nf
{
  for (int i = 1; i <= row; i++)
  {
    for (int j = 1; j <= col; j++)
    {
      (*this)(i,j) =  (*this)(i,j) * factor;
    }
  }
  return *this;
}
.fi
.SS "\fBDMatrix\fP DMatrix::operator* (\fBDMatrix\fP & right)"
.PP
Definition at line 171 of file dmatrix.h.
.PP
.nf
{
  DMatrix prod(row,right.col);
  for (int i = 1; i <= row; i++)
  {
    for (int j = 1; j <= right.col; j++)
    {
      prod(i,j) = 0;
      for (int k = 1; k <= col; k++)
    prod(i,j) = prod(i,j) + (*this)(i,k)*right(k,j);
    }
  }
  return prod;
}
.fi
.SS "\fBDMatrix\fP DMatrix::operator+ (\fBDMatrix\fP & right)"
.PP
Definition at line 153 of file dmatrix.h.
.PP
.nf
{
  DMatrix left(*this);
  for (int i = 1; i <= row*col; i++)
    left.elements[i] = left.elements[i] + right.elements[i];
  return left;
}
.fi
.SS "\fBDMatrix\fP DMatrix::operator- (\fBDMatrix\fP & right)"
.PP
Definition at line 161 of file dmatrix.h.
.PP
.nf
{
  DMatrix left(*this);
  for (int i = 1; i <= row*col; i++)
  {
    left.elements[i] = left.elements[i] - right.elements[i];
  }
  return left;
}
.fi
.SS "\fBDMatrix\fP & DMatrix::operator= (\fBDMatrix\fP & right)"
.PP
Definition at line 200 of file dmatrix.h.
.PP
.nf
{
  if (this == &right) return *this;
  else
    {
      delete elements;
      elements = new double[row*col+1];
      memcpy(elements,right.elements,(row*col+1)*sizeof(double));
      return *this;
    }
}
.fi
.SS "\fBDMatrix\fP DMatrix::operator~ ()"
.PP
Definition at line 262 of file dmatrix.h.
.PP
.nf
{
  int i, j, k, n;
  int pivrow, tarrow;
  double pivelt, tarelt;
  n = row; // Zahl d.Gleich.
  DMatrix aug(n,2*col);
  DMatrix inverse(n,col);
  for (i = 1; i <= n; i++)
    for (j = 1; j <= col; j++)
      aug(i,j) = (*this)(i,j);
  for (i = 1; i <= n; i++)
    for (j = n+1; j <= aug.col; j++)
      if (i == j-n) aug(i,j) = 1; // Einheitsmatrix
  for (pivrow = 1; pivrow <= n; pivrow++)
  {
    pivelt = aug(pivrow,pivrow);
    if (pivelt == 0)
    {
      k = pivrow + 1;   // Pivotsuche
      while (pivelt == 0 && k <= n)
      {
    pivelt = aug(k,pivrow);
    k++;
      }
      if (pivelt == 0)
      { cerr << 'dmatrix : ERROR - Inversion attempted, but matrix is singular!'; exit(1); }
    }
    else
    {k--;
    DMatrix dum(2*col);
    for (i = 1; i <= 2*col; i++)
      dum(i) = aug(pivrow,i);
    for (i = 1; i <= 2*col; i++)
      aug(pivrow,i) = aug(k,i);
    for (i = 1; i <= 2*col; i++)
      aug(k,i) = dum(i);
    }
  }

  for (j = 1; j <= 2*col; j++)
    aug(pivrow,j) = aug(pivrow,j)/pivelt;
  for (tarrow = 1; tarrow <= n; tarrow++)
    if (tarrow != pivrow)
    {
      tarelt = aug(tarrow,pivrow);
      for (j = 1; j<= 2*col; j++)
    aug(tarrow,j) = aug(tarrow,j) - aug(pivrow,j)*tarelt;
    }
  for (i = 1; i <= n; i++)
    for (j = n+1; j <= aug.col; j++)
      inverse(i,j-n) = aug(i,j);
  return inverse;
}
.fi
.SS "void DMatrix::Print ()"
.PP
Definition at line 228 of file dmatrix.h.
.PP
.nf
{
  cout.setf(ios::fixed);
  cout << setprecision(4);
  for (int i = 1; i <= row; i++)
  {
    for (int j = 1; j <= col; j++)
      cout << setw(8) << (*this)(i,j);
    cout << endl;
  }
}
.fi
.SS "double DMatrix::QuadSum ()"
.PP
Definition at line 251 of file dmatrix.h.
.PP
.nf
{
  double temp = 0.0;
  for (int i = 1; i <= row; i++)
    for (int j = 1; j <= col; j++)
      temp += (*this)(i,j)*(*this)(i,j);
  return temp;
}
.fi
.SS "double DMatrix::Sum ()"
.PP
Definition at line 242 of file dmatrix.h.
.PP
.nf
{
  double temp = 0.0;
  for (int i = 1; i <= row; i++)
    for (int j = 1; j <= col; j++)
      temp += (*this)(i,j);
  return temp;
}
.fi
.SH "Friends And Related Function Documentation"
.PP 
.SS "istream& operator>> (istream & is, \fBDMatrix\fP & m)\fC [friend]\fP"
.PP
Definition at line 319 of file dmatrix.h.
.PP
.nf
{
  for (int i = 1; i <= m.row; i++)
    for (int j = 1; j <= m.col; j++)
      is >> m(i,j);
  return is;
}
.fi


.SH "Author"
.PP 
Generated automatically by Doxygen for NetTrader from the source code.
