.TH "TNT::Fortran_Matrix" 3 "Wed Nov 17 2010" "Version 0.5" "NetTrader" \" -*- nroff -*-
.ad l
.nh
.SH NAME
TNT::Fortran_Matrix \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <fmat.h>\fP
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef T \fBvalue_type\fP"
.br
.ti -1c
.RI "typedef T \fBelement_type\fP"
.br
.ti -1c
.RI "typedef T * \fBpointer\fP"
.br
.ti -1c
.RI "typedef T * \fBiterator\fP"
.br
.ti -1c
.RI "typedef T & \fBreference\fP"
.br
.ti -1c
.RI "typedef const T * \fBconst_iterator\fP"
.br
.ti -1c
.RI "typedef const T & \fBconst_reference\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBSubscript\fP \fBlbound\fP () const "
.br
.ti -1c
.RI "T * \fBbegin\fP ()"
.br
.ti -1c
.RI "const T * \fBbegin\fP () const "
.br
.ti -1c
.RI "T * \fBend\fP ()"
.br
.ti -1c
.RI "const T * \fBend\fP () const "
.br
.ti -1c
.RI "\fBFortran_Matrix\fP ()"
.br
.ti -1c
.RI "\fBFortran_Matrix\fP (const \fBFortran_Matrix\fP< T > &A)"
.br
.ti -1c
.RI "\fBFortran_Matrix\fP (\fBSubscript\fP M, \fBSubscript\fP N, const T &value=T())"
.br
.ti -1c
.RI "\fBFortran_Matrix\fP (\fBSubscript\fP M, \fBSubscript\fP N, const T *v)"
.br
.ti -1c
.RI "\fBFortran_Matrix\fP (\fBSubscript\fP M, \fBSubscript\fP N, char *s)"
.br
.ti -1c
.RI "\fB~Fortran_Matrix\fP ()"
.br
.ti -1c
.RI "\fBFortran_Matrix\fP< T > & \fBoperator=\fP (const \fBFortran_Matrix\fP< T > &A)"
.br
.ti -1c
.RI "\fBFortran_Matrix\fP< T > & \fBoperator=\fP (const T &scalar)"
.br
.ti -1c
.RI "\fBSubscript\fP \fBdim\fP (\fBSubscript\fP d) const "
.br
.ti -1c
.RI "\fBSubscript\fP \fBnum_rows\fP () const "
.br
.ti -1c
.RI "\fBSubscript\fP \fBnum_cols\fP () const "
.br
.ti -1c
.RI "\fBFortran_Matrix\fP< T > & \fBnewsize\fP (\fBSubscript\fP M, \fBSubscript\fP N)"
.br
.ti -1c
.RI "\fBreference\fP \fBoperator()\fP (\fBSubscript\fP i, \fBSubscript\fP j)"
.br
.ti -1c
.RI "\fBconst_reference\fP \fBoperator()\fP (\fBSubscript\fP i, \fBSubscript\fP j) const "
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fBinitialize\fP (\fBSubscript\fP M, \fBSubscript\fP N)"
.br
.ti -1c
.RI "void \fBcopy\fP (const T *v)"
.br
.ti -1c
.RI "void \fBset\fP (const T &val)"
.br
.ti -1c
.RI "void \fBdestroy\fP ()"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "T * \fBv_\fP"
.br
.ti -1c
.RI "\fBSubscript\fP \fBm_\fP"
.br
.ti -1c
.RI "\fBSubscript\fP \fBn_\fP"
.br
.ti -1c
.RI "T ** \fBcol_\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<class T> class TNT::Fortran_Matrix< T >"

.PP
Definition at line 47 of file fmat.h.
.SH "Member Typedef Documentation"
.PP 
.SS "template<class T> typedef const T* \fBTNT::Fortran_Matrix\fP< T >::\fBconst_iterator\fP"
.PP
Definition at line 58 of file fmat.h.
.SS "template<class T> typedef const T& \fBTNT::Fortran_Matrix\fP< T >::\fBconst_reference\fP"
.PP
Definition at line 59 of file fmat.h.
.SS "template<class T> typedef T \fBTNT::Fortran_Matrix\fP< T >::\fBelement_type\fP"
.PP
Definition at line 54 of file fmat.h.
.SS "template<class T> typedef T* \fBTNT::Fortran_Matrix\fP< T >::\fBiterator\fP"
.PP
Definition at line 56 of file fmat.h.
.SS "template<class T> typedef T* \fBTNT::Fortran_Matrix\fP< T >::\fBpointer\fP"
.PP
Definition at line 55 of file fmat.h.
.SS "template<class T> typedef T& \fBTNT::Fortran_Matrix\fP< T >::\fBreference\fP"
.PP
Definition at line 57 of file fmat.h.
.SS "template<class T> typedef T \fBTNT::Fortran_Matrix\fP< T >::\fBvalue_type\fP"
.PP
Definition at line 53 of file fmat.h.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<class T> \fBTNT::Fortran_Matrix\fP< T >::\fBFortran_Matrix\fP ()\fC [inline]\fP"
.PP
Definition at line 176 of file fmat.h.
.PP
.nf
: v_(0), m_(0), n_(0), col_(0)  {};
.fi
.SS "template<class T> \fBTNT::Fortran_Matrix\fP< T >::\fBFortran_Matrix\fP (const \fBFortran_Matrix\fP< T > & A)\fC [inline]\fP"
.PP
Definition at line 177 of file fmat.h.
.PP
References TNT::Fortran_Matrix< T >::copy(), TNT::Fortran_Matrix< T >::initialize(), TNT::Fortran_Matrix< T >::m_, TNT::Fortran_Matrix< T >::n_, and TNT::Fortran_Matrix< T >::v_.
.PP
.nf
    {
        initialize(A.m_, A.n_);
        copy(A.v_);
    }
.fi
.SS "template<class T> \fBTNT::Fortran_Matrix\fP< T >::\fBFortran_Matrix\fP (\fBSubscript\fP M, \fBSubscript\fP N, const T & value = \fCT()\fP)\fC [inline]\fP"
.PP
Definition at line 183 of file fmat.h.
.PP
References TNT::Fortran_Matrix< T >::initialize().
.PP
.nf
    {
        initialize(M,N);
        set(value);
    }
.fi
.SS "template<class T> \fBTNT::Fortran_Matrix\fP< T >::\fBFortran_Matrix\fP (\fBSubscript\fP M, \fBSubscript\fP N, const T * v)\fC [inline]\fP"
.PP
Definition at line 189 of file fmat.h.
.PP
References TNT::Fortran_Matrix< T >::copy(), and TNT::Fortran_Matrix< T >::initialize().
.PP
.nf
    {
        initialize(M,N);
        copy(v);
    }
.fi
.SS "template<class T> \fBTNT::Fortran_Matrix\fP< T >::\fBFortran_Matrix\fP (\fBSubscript\fP M, \fBSubscript\fP N, char * s)\fC [inline]\fP"
.PP
Definition at line 196 of file fmat.h.
.PP
References TNT::Fortran_Matrix< T >::initialize().
.PP
.nf
    {
        initialize(M,N);
        std::istrstream ins(s);

        Subscript i, j;

        for (i=1; i<=M; i++)
            for (j=1; j<=N; j++)
                ins >> (*this)(i,j);
    }
.fi
.SS "template<class T> \fBTNT::Fortran_Matrix\fP< T >::~\fBFortran_Matrix\fP ()\fC [inline]\fP"
.PP
Definition at line 209 of file fmat.h.
.PP
References TNT::Fortran_Matrix< T >::destroy().
.PP
.nf
    {
        destroy();
    }
.fi
.SH "Member Function Documentation"
.PP 
.SS "template<class T> T* \fBTNT::Fortran_Matrix\fP< T >::begin ()\fC [inline]\fP"
.PP
Definition at line 167 of file fmat.h.
.PP
References TNT::Fortran_Matrix< T >::v_.
.PP
Referenced by TNT::operator*(), and Upper_symmetric_eigenvalue_solve().
.PP
.nf
{ return v_; }
.fi
.SS "template<class T> const T* \fBTNT::Fortran_Matrix\fP< T >::begin () const\fC [inline]\fP"
.PP
Definition at line 168 of file fmat.h.
.PP
References TNT::Fortran_Matrix< T >::v_.
.PP
.nf
{ return v_;}
.fi
.SS "template<class T> void \fBTNT::Fortran_Matrix\fP< T >::copy (const T * v)\fC [inline, protected]\fP"
.PP
Definition at line 98 of file fmat.h.
.PP
References TNT::Fortran_Matrix< T >::m_, TNT::Fortran_Matrix< T >::n_, and TNT::Fortran_Matrix< T >::v_.
.PP
Referenced by TNT::Fortran_Matrix< T >::Fortran_Matrix(), and TNT::Fortran_Matrix< T >::operator=().
.PP
.nf
    {
        Subscript N = m_ * n_;
        Subscript i;

#ifdef TNT_UNROLL_LOOPS
        Subscript Nmod4 = N & 3;
        Subscript N4 = N - Nmod4;

        for (i=0; i<N4; i+=4)
        {
            v_[i] = v[i];
            v_[i+1] = v[i+1];
            v_[i+2] = v[i+2];
            v_[i+3] = v[i+3];
        }

        for (i=N4; i< N; i++)
            v_[i] = v[i];
#else

        for (i=0; i< N; i++)
            v_[i] = v[i];
#endif      
    }
.fi
.SS "template<class T> void \fBTNT::Fortran_Matrix\fP< T >::destroy ()\fC [inline, protected]\fP"
.PP
Definition at line 153 of file fmat.h.
.PP
References TNT::Fortran_Matrix< T >::col_, and TNT::Fortran_Matrix< T >::v_.
.PP
Referenced by TNT::Fortran_Matrix< T >::newsize(), TNT::Fortran_Matrix< T >::operator=(), and TNT::Fortran_Matrix< T >::~Fortran_Matrix().
.PP
.nf
    {     
        /* do nothing, if no memory has been previously allocated */
        if (v_ == NULL) return ;

        /* if we are here, then matrix was previously allocated */
        delete [] (v_);     
        col_ ++;                // changed back to 0-offset
        delete [] (col_);
    }
.fi
.SS "template<class T> \fBSubscript\fP \fBTNT::Fortran_Matrix\fP< T >::dim (\fBSubscript\fP d) const\fC [inline]\fP"
.PP
Definition at line 242 of file fmat.h.
.PP
References TNT::Fortran_Matrix< T >::m_, and TNT::Fortran_Matrix< T >::n_.
.PP
.nf
    {
#ifdef TNT_BOUNDS_CHECK
       assert( d >= 1);
        assert( d <= 2);
#endif
        return (d==1) ? m_ : ((d==2) ? n_ : 0); 
    }
.fi
.SS "template<class T> T* \fBTNT::Fortran_Matrix\fP< T >::end ()\fC [inline]\fP"
.PP
Definition at line 170 of file fmat.h.
.PP
References TNT::Fortran_Matrix< T >::m_, TNT::Fortran_Matrix< T >::n_, and TNT::Fortran_Matrix< T >::v_.
.PP
Referenced by TNT::operator*().
.PP
.nf
{ return v_ + m_*n_; }
.fi
.SS "template<class T> const T* \fBTNT::Fortran_Matrix\fP< T >::end () const\fC [inline]\fP"
.PP
Definition at line 171 of file fmat.h.
.PP
References TNT::Fortran_Matrix< T >::m_, TNT::Fortran_Matrix< T >::n_, and TNT::Fortran_Matrix< T >::v_.
.PP
.nf
{ return v_ + m_*n_; }
.fi
.SS "template<class T> void \fBTNT::Fortran_Matrix\fP< T >::initialize (\fBSubscript\fP M, \fBSubscript\fP N)\fC [inline, protected]\fP"
.PP
Definition at line 72 of file fmat.h.
.PP
References TNT::Fortran_Matrix< T >::col_, TNT::Fortran_Matrix< T >::m_, TNT::Fortran_Matrix< T >::n_, and TNT::Fortran_Matrix< T >::v_.
.PP
Referenced by TNT::Fortran_Matrix< T >::Fortran_Matrix(), TNT::Fortran_Matrix< T >::newsize(), and TNT::Fortran_Matrix< T >::operator=().
.PP
.nf
    {
        // adjust col_[] pointers so that they are 1-offset:
        //   col_[j][i] is really col_[j-1][i-1];
        //
        // v_[] is the internal contiguous array, it is still 0-offset
        //
        v_ = new T[M*N];
        col_ = new T*[N];

        assert(v_  != NULL);
        assert(col_ != NULL);


        m_ = M;
        n_ = N;
        T* p = v_ - 1;              
        for (Subscript i=0; i<N; i++)
        {
            col_[i] = p;
            p += M ;
            
        }
        col_ --; 
    }
.fi
.SS "template<class T> \fBSubscript\fP \fBTNT::Fortran_Matrix\fP< T >::lbound () const\fC [inline]\fP"
.PP
Definition at line 61 of file fmat.h.
.PP
.nf
{ return 1;}
.fi
.SS "template<class T> \fBFortran_Matrix\fP<T>& \fBTNT::Fortran_Matrix\fP< T >::newsize (\fBSubscript\fP M, \fBSubscript\fP N)\fC [inline]\fP"
.PP
Definition at line 254 of file fmat.h.
.PP
References TNT::Fortran_Matrix< T >::destroy(), TNT::Fortran_Matrix< T >::initialize(), TNT::Fortran_Matrix< T >::num_cols(), and TNT::Fortran_Matrix< T >::num_rows().
.PP
Referenced by TNT::matmult(), and TNT::operator>>().
.PP
.nf
    {
        if (num_rows() == M && num_cols() == N)
            return *this;

        destroy();
        initialize(M,N);

        return *this;
    }
.fi
.SS "template<class T> \fBSubscript\fP \fBTNT::Fortran_Matrix\fP< T >::num_cols () const\fC [inline]\fP"
.PP
Definition at line 252 of file fmat.h.
.PP
References TNT::Fortran_Matrix< T >::n_.
.PP
Referenced by eigenvalue_solve(), Lapack_LLS_QR_linear_solve(), Lapack_LU_linear_solve(), TNT::matmult(), TNT::mult_element(), TNT::Fortran_Matrix< T >::newsize(), TNT::operator*(), TNT::operator+(), TNT::operator-(), TNT::operator>>(), TNT::transpose(), and Upper_symmetric_eigenvalue_solve().
.PP
.nf
{ return n_; }
.fi
.SS "template<class T> \fBSubscript\fP \fBTNT::Fortran_Matrix\fP< T >::num_rows () const\fC [inline]\fP"
.PP
Definition at line 251 of file fmat.h.
.PP
References TNT::Fortran_Matrix< T >::m_.
.PP
Referenced by eigenvalue_solve(), Lapack_LLS_QR_linear_solve(), Lapack_LU_linear_solve(), TNT::matmult(), TNT::mult_element(), TNT::Fortran_Matrix< T >::newsize(), TNT::operator*(), TNT::operator+(), TNT::operator-(), TNT::operator>>(), TNT::transpose(), and Upper_symmetric_eigenvalue_solve().
.PP
.nf
{ return m_; }
.fi
.SS "template<class T> \fBreference\fP \fBTNT::Fortran_Matrix\fP< T >::operator() (\fBSubscript\fP i, \fBSubscript\fP j)\fC [inline]\fP"
.PP
Definition at line 269 of file fmat.h.
.PP
References TNT::Fortran_Matrix< T >::col_, TNT::Fortran_Matrix< T >::m_, and TNT::Fortran_Matrix< T >::n_.
.PP
.nf
    { 
#ifdef TNT_BOUNDS_CHECK
        assert(1<=i);
        assert(i <= m_) ;
        assert(1<=j);
        assert(j <= n_);
#endif
        return col_[j][i]; 
    }
.fi
.SS "template<class T> \fBconst_reference\fP \fBTNT::Fortran_Matrix\fP< T >::operator() (\fBSubscript\fP i, \fBSubscript\fP j) const\fC [inline]\fP"
.PP
Definition at line 280 of file fmat.h.
.PP
References TNT::Fortran_Matrix< T >::col_, TNT::Fortran_Matrix< T >::m_, and TNT::Fortran_Matrix< T >::n_.
.PP
.nf
    {
#ifdef TNT_BOUNDS_CHECK
        assert(1<=i);
        assert(i <= m_) ;
        assert(1<=j);
        assert(j <= n_);
#endif
        return col_[j][i]; 
    }
.fi
.SS "template<class T> \fBFortran_Matrix\fP<T>& \fBTNT::Fortran_Matrix\fP< T >::operator= (const T & scalar)\fC [inline]\fP"
.PP
Definition at line 235 of file fmat.h.
.PP
.nf
    { 
        set(scalar); 
        return *this;
    }
.fi
.SS "template<class T> \fBFortran_Matrix\fP<T>& \fBTNT::Fortran_Matrix\fP< T >::operator= (const \fBFortran_Matrix\fP< T > & A)\fC [inline]\fP"
.PP
Definition at line 217 of file fmat.h.
.PP
References TNT::Fortran_Matrix< T >::copy(), TNT::Fortran_Matrix< T >::destroy(), TNT::Fortran_Matrix< T >::initialize(), TNT::Fortran_Matrix< T >::m_, TNT::Fortran_Matrix< T >::n_, and TNT::Fortran_Matrix< T >::v_.
.PP
.nf
    {
        if (v_ == A.v_)
            return *this;

        if (m_ == A.m_  && n_ == A.n_)      // no need to re-alloc
            copy(A.v_);

        else
        {
            destroy();
            initialize(A.m_, A.n_);
            copy(A.v_);
        }

        return *this;
    }
.fi
.SS "template<class T> void \fBTNT::Fortran_Matrix\fP< T >::set (const T & val)\fC [inline, protected]\fP"
.PP
Definition at line 124 of file fmat.h.
.PP
References TNT::Fortran_Matrix< T >::m_, TNT::Fortran_Matrix< T >::n_, and TNT::Fortran_Matrix< T >::v_.
.PP
.nf
    {
        Subscript N = m_ * n_;
        Subscript i;

#ifdef TNT_UNROLL_LOOPS
        Subscript Nmod4 = N & 3;
        Subscript N4 = N - Nmod4;

        for (i=0; i<N4; i+=4)
        {
            v_[i] = val;
            v_[i+1] = val;
            v_[i+2] = val;
            v_[i+3] = val; 
        }

        for (i=N4; i< N; i++)
            v_[i] = val;
#else

        for (i=0; i< N; i++)
            v_[i] = val;
        
#endif      
    }
.fi
.SH "Member Data Documentation"
.PP 
.SS "template<class T> T** \fBTNT::Fortran_Matrix\fP< T >::\fBcol_\fP\fC [protected]\fP"
.PP
Definition at line 67 of file fmat.h.
.PP
Referenced by TNT::Fortran_Matrix< T >::destroy(), TNT::Fortran_Matrix< T >::initialize(), and TNT::Fortran_Matrix< T >::operator()().
.SS "template<class T> \fBSubscript\fP \fBTNT::Fortran_Matrix\fP< T >::\fBm_\fP\fC [protected]\fP"
.PP
Definition at line 65 of file fmat.h.
.PP
Referenced by TNT::Fortran_Matrix< T >::copy(), TNT::Fortran_Matrix< T >::dim(), TNT::Fortran_Matrix< T >::end(), TNT::Fortran_Matrix< T >::Fortran_Matrix(), TNT::Fortran_Matrix< T >::initialize(), TNT::Fortran_Matrix< T >::num_rows(), TNT::Fortran_Matrix< T >::operator()(), TNT::Fortran_Matrix< T >::operator=(), and TNT::Fortran_Matrix< T >::set().
.SS "template<class T> \fBSubscript\fP \fBTNT::Fortran_Matrix\fP< T >::\fBn_\fP\fC [protected]\fP"
.PP
Definition at line 66 of file fmat.h.
.PP
Referenced by TNT::Fortran_Matrix< T >::copy(), TNT::Fortran_Matrix< T >::dim(), TNT::Fortran_Matrix< T >::end(), TNT::Fortran_Matrix< T >::Fortran_Matrix(), TNT::Fortran_Matrix< T >::initialize(), TNT::Fortran_Matrix< T >::num_cols(), TNT::Fortran_Matrix< T >::operator()(), TNT::Fortran_Matrix< T >::operator=(), and TNT::Fortran_Matrix< T >::set().
.SS "template<class T> T* \fBTNT::Fortran_Matrix\fP< T >::\fBv_\fP\fC [protected]\fP"
.PP
Definition at line 64 of file fmat.h.
.PP
Referenced by TNT::Fortran_Matrix< T >::begin(), TNT::Fortran_Matrix< T >::copy(), TNT::Fortran_Matrix< T >::destroy(), TNT::Fortran_Matrix< T >::end(), TNT::Fortran_Matrix< T >::Fortran_Matrix(), TNT::Fortran_Matrix< T >::initialize(), TNT::Fortran_Matrix< T >::operator=(), and TNT::Fortran_Matrix< T >::set().

.SH "Author"
.PP 
Generated automatically by Doxygen for NetTrader from the source code.
